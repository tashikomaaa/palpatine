#!/usr/bin/env bash
#!/bin/bash
# Palapatine - Open Source Project
# Copyright (C) 2025  Moutarlier Aldwin aka (tashikomaaa or corvus)
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.


set -euo pipefail
IFS=$'\n\t'

# Resolve script path even when launched via symlink
PALPATINE_SOURCE="${BASH_SOURCE[0]}"
while [[ -h "$PALPATINE_SOURCE" ]]; do
  PALPATINE_DIR="$(cd -P "$(dirname "$PALPATINE_SOURCE")" && pwd)"
  LINK_TARGET="$(readlink "$PALPATINE_SOURCE")"
  if [[ "$LINK_TARGET" == /* ]]; then
    PALPATINE_SOURCE="$LINK_TARGET"
  else
    PALPATINE_SOURCE="$PALPATINE_DIR/$LINK_TARGET"
  fi
done

BASE_DIR="$(cd -P "$(dirname "$PALPATINE_SOURCE")" && pwd)"
LIB_DIR="$BASE_DIR/lib"

# ----------------------------
# Load configuration files (if any)
# Precedence: /etc/palpatine.conf -> $HOME/.palpatine.conf -> $PWD/.palpatine.conf
# These files should set variables like GROUP, SSH_USER, MAX_JOBS, SSH_TIMEOUT, UI_LANG, DRY_RUN, etc.
# ----------------------------
CONFIG_PATHS=(
  "/etc/palpatine.conf"
  "$HOME/.palpatine.conf"
  "$PWD/.palpatine.conf"
)

for conf in "${CONFIG_PATHS[@]}"; do
  if [[ -f "$conf" ]]; then
    # shellcheck disable=SC1090
    source "$conf"
  fi
done

# ----------------------------
# Source library files
# All core functions live in lib/*.sh
# ----------------------------
for file in "$LIB_DIR"/*.sh; do
  # shellcheck disable=SC1090
  source "$file"
done

# Load optional plugins (if any register themselves)
load_plugins

# Remember original arguments for potential restarts
ORIGINAL_ARGS=("$@")

# Update checking helper (git-based)
maybe_check_for_updates(){
  local interval="${UPDATE_CHECK_INTERVAL:-86400}"
  local remote="${UPDATE_REMOTE:-origin}"
  local branch="${UPDATE_BRANCH:-main}"

  [[ "${DISABLE_UPDATE_CHECK:-}" == "true" ]] && return
  command -v git >/dev/null 2>&1 || return
  [[ -d "$BASE_DIR/.git" ]] || return

  mkdir -p "$LOG_DIR"
  local stamp_file="$LOG_DIR/.update-check"
  local now last ts_diff
  now=$(date +%s 2>/dev/null || echo 0)
  if [[ -f "$stamp_file" ]]; then
    last=$(<"$stamp_file")
    [[ -n "$last" ]] || last=0
    ts_diff=$(( now - last ))
    if (( ts_diff < interval )); then
      return
    fi
  fi

  if ! git -C "$BASE_DIR" remote get-url "$remote" >/dev/null 2>&1; then
    return
  fi

  if ! git -C "$BASE_DIR" fetch --quiet "$remote" "$branch" >/dev/null 2>&1; then
    return
  fi

  printf '%s' "$now" > "$stamp_file"

  local local_rev remote_rev
  local_rev=$(git -C "$BASE_DIR" rev-parse HEAD 2>/dev/null) || return
  remote_rev=$(git -C "$BASE_DIR" rev-parse "$remote/$branch" 2>/dev/null) || return

  if [[ "$local_rev" == "$remote_rev" ]]; then
    return
  fi

  alert "Update available for Palpatine ($remote/$branch)."
  local prompt ans
  prompt=$'\e[94m'"A newer version is available. Update now? [y/N]: "
  read -rp "${prompt}${COL_RESET}" ans || ans=""
  if [[ ! "$ans" =~ ^[yY]$ ]]; then
    alert "Skipping update. Run 'git -C $BASE_DIR pull --ff-only $remote $branch' later."
    return
  fi

  if [[ -n $(git -C "$BASE_DIR" status --porcelain) ]]; then
    failure "Working tree has local changes. Commit or stash before updating."
    return
  fi

  if git -C "$BASE_DIR" pull --ff-only "$remote" "$branch"; then
    victory "Repository updated. Restarting Palpatine..."
    exec "$0" "${ORIGINAL_ARGS[@]}"
  else
    failure "Automatic update failed. Please update manually."
  fi
}

# Opening loader (ASCII art banner)
show_loader(){
  cat <<'EOF'
                  ⢠⣲⣼⠛⠛⣧⣖⡄⠀⠀
                ⢠⡲⠙⠁⠀⢰⡆⠀⠈⠋⢖⡄
                ⣶⡗⠀⠛⢦⣾⣷⣴⠛⠀⢺⣶
                ⠿⡧⠀⣤⠞⢿⡿⠻⣤⠀⢼⠿
                ⠘⠵⣠⡀⠀⠸⠇⠀⢀⣤⠮⠃
                ⠀⠀⠘⠽⢻⣤⣤⡟⠯⠃⠀
__________        .__                __  .__               
\______   \_____  |  | ___________ _/  |_|__| ____   ____  
 |     ___/\__  \ |  | \____ \__  \\   __\  |/    \_/ __ \ 
 |    |     / __ \|  |_|  |_> > __ \|  | |  |   |  \  ___/ 
 |____|    (____  /____/   __(____  /__| |__|___|  /\___  >
                \/     |__|       \/             \/     \/ 
⠀
         
EOF
  sleep 2
  clear
}

show_loader

prompt_add_server(){
  local input prompt
  prompt=$'\e[94m'"$(L 'prompt.add_server' 2>/dev/null || echo 'Server to add:') "
  read -rp "${prompt}${COL_RESET}" input
  if [[ -z "${input//[[:space:]]/}" ]]; then
    alert "$(L 'alert.cancel' 2>/dev/null || echo 'Operation cancelled.')"
    return
  fi
  if add_server_entry "$input"; then
    load_servers
  fi
}

prompt_remove_server(){
  local input prompt target idx

  if (( ${#SERVERS[@]} == 0 )); then
    alert "$(L 'msg.no_servers' 2>/dev/null || echo 'No servers found.')"
    return
  fi

  draw_line
  echo -e " ${COL_MENU}$(L 'menu.remove_server' 2>/dev/null || echo 'Remove a server')${COL_RESET}"
  local i=1
  for srv in "${SERVERS[@]}"; do
    printf '  [%d] %s\n' "$i" "$srv"
    ((i++))
  done
  draw_line

  prompt=$'\e[94m'"$(L 'prompt.remove_server' 2>/dev/null || echo 'Server to remove (number or host):') "
  read -rp "${prompt}${COL_RESET}" input
  input="${input//[[:space:]]/}"
  if [[ -z "$input" ]]; then
    alert "$(L 'alert.cancel' 2>/dev/null || echo 'Operation cancelled.')"
    return
  fi

  if [[ "$input" =~ ^[0-9]+$ ]]; then
    idx=$input
    if (( idx >= 1 && idx <= ${#SERVERS[@]} )); then
      target="${SERVERS[$((idx-1))]}"
    else
      alert "$(L 'alert.invalid' 2>/dev/null || echo 'Invalid choice.')"
      return
    fi
  else
    target="$input"
  fi

  if remove_server_entry "$target"; then
    load_servers
  fi
}

# ----------------------------
# CLI argument parsing
# ----------------------------
ACTION=""      # status|run|reboot|shutdown
CMDLINE=""     # command for run
FOCUS=""       # focus server (name or index)
ADD_SERVER=""
REMOVE_SERVER=""
PLAYBOOK=""

print_help(){
  cat <<EOF
$APP_NAME $VERSION - $TAGLINE

Usage:
  $0 [--group <name>] [--user <sshuser>] [--dry-run]
     [--action <status|run|reboot|shutdown>] [--cmd "<command>"]
     [--focus "<server|index>"] [--add-server <host>] [--remove-server <host>]
     [--playbook <file>] [--help]

Examples:
  $0 --group prod --action status
  $0 --group staging --action run --cmd "df -h"
  $0 --action reboot --dry-run
  $0 --focus "root@web-01"
  $0 --group prod --add-server "admin@web-04"
  $0 --remove-server "legacy-host"
  $0 --playbook playbooks/sample.playbook
EOF
}

while [[ $# -gt 0 ]]; do
  case "$1" in
    --group) GROUP="$2"; shift ;;
    --user) SSH_USER="$2"; shift ;;
    --action) ACTION="$2"; shift ;;
    --cmd) CMDLINE="$2"; shift ;;
    --dry-run) DRY_RUN=true ;;
    --focus) FOCUS="$2"; shift ;;
    --add-server) ADD_SERVER="$2"; shift ;;
    --remove-server) REMOVE_SERVER="$2"; shift ;;
    --playbook) PLAYBOOK="$2"; shift ;;
    -h|--help) print_help; exit 0 ;;
    *) failure "Invalid option: $1"; print_help; exit 2 ;;
  esac
  shift
done

# Prevent conflicting options
if [[ -n "$PLAYBOOK" ]]; then
  if [[ -n "${ACTION:-}" ]]; then
    failure "--playbook cannot be combined with --action"
    exit 2
  fi
  if [[ -n "${FOCUS:-}" ]]; then
    failure "--playbook cannot be combined with --focus"
    exit 2
  fi
  if [[ -n "$ADD_SERVER" || -n "$REMOVE_SERVER" ]]; then
    failure "--playbook cannot be combined with --add-server/--remove-server"
    exit 2
  fi
fi

# ----------------------------
# Server list management (non-interactive shortcuts)
# ----------------------------
if [[ -n "$ADD_SERVER" && -n "$REMOVE_SERVER" ]]; then
  failure "Cannot use --add-server and --remove-server at the same time."
  exit 2
fi

if [[ -n "$ADD_SERVER" ]]; then
  if add_server_entry "$ADD_SERVER"; then
    exit 0
  else
    exit 1
  fi
fi

if [[ -n "$REMOVE_SERVER" ]]; then
  if remove_server_entry "$REMOVE_SERVER"; then
    exit 0
  else
    exit 1
  fi
fi

# ----------------------------
# Bootstrap UI and load servers
# ----------------------------

# Show animated intro only in interactive mode
if [[ -z "${ACTION:-}" && -z "${PLAYBOOK:-}" && -z "${FOCUS:-}" && -t 0 ]]; then
  # Add intro animation flag to avoid showing it multiple times
  if [[ "${SHOW_INTRO:-true}" == "true" ]]; then
    animate_intro
    export SHOW_INTRO=false
  fi
fi

draw_header
load_servers

maybe_check_for_updates

# ----------------------------
# Playbook mode
# ----------------------------
if [[ -n "$PLAYBOOK" ]]; then
  if run_playbook "$PLAYBOOK"; then
    exit 0
  else
    exit 1
  fi
fi

# ----------------------------
# If focus requested directly
# ----------------------------
if [[ -n "${FOCUS:-}" ]]; then
  case "$FOCUS" in
    ''|*[!0-9]*) focus_server "$FOCUS" ;;
    *)
      if (( FOCUS >= 1 && FOCUS <= ${#SERVERS[@]} )); then
        focus_server "${SERVERS[$((FOCUS-1))]}"
      else
        failure "Invalid server index: $FOCUS"
        exit 2
      fi
      ;;
  esac
  exit 0
fi

# ----------------------------
# Non-interactive mode if ACTION provided
# ----------------------------
if [[ -n "${ACTION:-}" ]]; then
  case "$ACTION" in
    status) action_status ;;
    run)
      [[ -z "${CMDLINE:-}" ]] && { failure "--cmd is required with --action run."; exit 1; }
      action_run_command
      ;;
    reboot) action_reboot_or_shutdown "reboot" ;;
    shutdown) action_reboot_or_shutdown "shutdown" ;;
    *) failure "Unknown action: $ACTION"; exit 1 ;;
  esac
  exit 0
fi

# ----------------------------
# Interactive TUI main loop (k9s-style)
# ----------------------------
while :; do
  draw_header

  # Display server table (k9s style)
  draw_server_table "IMPERIAL FLEET ROSTER"

  # Dynamic menu options
  option_plugin=0
  option_add=0
  option_remove=0
  next_option=7

  if plugins_available; then
    option_plugin=$next_option
    ((next_option++))
  fi

  option_add=$next_option
  ((next_option++))

  option_remove=$next_option

  # Command menu at bottom (k9s style)
  draw_command_menu

  echo ""
  printf " ${COL_SUB}Additional commands:${COL_RESET}\n"
  if (( option_plugin > 0 )); then
    echo -e " ${COL_MENU}<${option_plugin}> $(L 'menu.plugins')${COL_RESET}  ${COL_MENU}<${option_add}> $(L 'menu.add_server')${COL_RESET}  ${COL_MENU}<${option_remove}> $(L 'menu.remove_server')${COL_RESET}"
  else
    echo -e " ${COL_MENU}<${option_add}> $(L 'menu.add_server')${COL_RESET}  ${COL_MENU}<${option_remove}> $(L 'menu.remove_server')${COL_RESET}"
  fi
  echo ""

  choice_prompt=$'\e[36m'"[COMMAND]> "
  read -rp "${choice_prompt}${COL_RESET}" choice
  choice="${choice,,}"

  # Screen transition before action
  [[ "$choice" =~ ^[1-5]$ ]] && screen_wipe

  case "$choice" in
    1|"s")
      action_status
      flash_screen "$COL_OK" 1
      pause
      ;;
    2)
      action_run_command
      pause
      ;;
    3|"r")
      action_reboot_or_shutdown "reboot"
      pause
      ;;
    4)
      action_reboot_or_shutdown "shutdown"
      pause
      ;;
    5)
      select_server
      ;;
    "$option_plugin"|"p")
      if (( option_plugin > 0 )) && plugins_available; then
        screen_wipe
        show_plugin_menu
      else
        alert "$(L 'plugins.none')"
      fi
      ;;
    "$option_add"|"a")
      prompt_add_server
      pause
      ;;
    "$option_remove"|"d")
      prompt_remove_server
      pause
      ;;
    9|"q")
      flash_screen "$COL_INFO" 1
      victory "$(L 'victory.farewell')"
      exit 0
      ;;
    *)
      alert "$(L 'alert.invalid')"
      sleep 0.5
      ;;
  esac
done
